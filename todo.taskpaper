
Images:
	- move to minimagick instead of miso
	- figure out how to make this install as a gem (i.e. remove external imagemagick binaries)
	- enable other tasks other then resize as part of the definition (e.g. greyscale)
	- enable default transforms for all images (e.g. remove metadata) -- look at making this configurable on a per-format basis

	
Naming:
	- 'Facet' -> 'Piece' @done
	- 'Slot' -> 'Box' @done
	- Make slots/boxes work like fields. Has far reaching consequences but I think the results will be bloody marvellous @done
	- rename db columns


UI:
	- Boxes have a 'help_text' attribute that shows up as contextual help in UI  ('?' after box name)
	- Browser feature detection @done
	- Loading progress @done
	
	
	- Uploads continue even when moving away from page @done
	- Return to page restores individual progress bars @done
	
	- Saving does text then queues images (through same progress mechanism as D&D image replacement) @done
	- Save item doesn't block @done
	- Estimated time for Uploads @done
	- Dual progress bar or have unified one only in status bar and rely in re-linking of individual progress indicators? @done
	- Should be able to drop images onto image preview in editing dialogue @done
	- 'Escape' should close/cancel dialogue @done
	- 'Format' switch in preview view
	- Show URL in preview view
	- Back & forward buttons in preview view?
	- Save state with # parts @done
	- UI reflects all changes to page title
	- Page entries have toggle to show & hide fields (?)
	- Paging of entries
	- URL editing @done
	- Cancel by ESC & button for URL editing @done
	- Cancel button for path editing
	- Separate treatment of title field in page?
	
	- Only accepting certain formats for d&d (link field formats to UI)
	
	- Attach URL editing/displaying box to bottom of page-info and then animate #page-info {height:'+10'} to expand for editing... @done
	- Preview mode is not using the edited URL of current page
	- Developer info (post User stuff)
	- Editing of page UID
	- Page publish/modification status
	- Piece publish/modification status
	- Markdown editor
	- Publishing interface @done
	- Aliasing interface
	- Fix for preview view not using updated url @done
	- Fix for preview view using cached version @done
	- Drag & drop updating of image in edit dialogue @done
	- Clearing of images
	- Move to top & bottom of slot
	
Backend:

	- Lightweight config system, requirable independently @done
	- Config DSL without fixed keys @done
	- Fix image insertion on creation using after_save instance hook?
	- Look into Text not rendering on Project pages @done
	- Look into inline image size definitions not working (see Project in example application) @done
	- Files should have their names sanitised @done
	- Change 'default_value' do 'default' in field definitions @done
	- Visibility needs to be in the JSON @done
	- Showability needs to be in the JSON
	- Rename the to_json calls to 'serialise' or something to avoid potential JSON format clashes
	- Page#show -> Page#request_show, Page#redirect -> Page#request-redirect ? Whatever, I need new names for these methods @done
	- Visibility changes should generate a changeset including all pages updated
	- As should slug/path changes

Templates:
	- {{ }}, {$ $}, {% %} ==> #{ }, ${ }, %{ } @done
	- Context is clever about what is rendered render(format) called on objects or to_s if #render not found @done
	- Cutaneous, "Of the skin" (.cut)? @done
	- Instantaneous, "Occurring, arising, or functioning without any delay" (.ins)? @done
	- Some useful handling of invalid tags in template
	- Look at fix for Spontaneous:: namespace (i.e. can't just use 'Site' have to use Spontaneous::Site)
	- Generate a Page class that inherits from Spontaneous::Page
	- Set up a top level Site class that links to Spontaneous::Site
	- Switch to kramdown for markdown processing http://kramdown.rubyforge.org/index.html

Preview:

	- Track modification and provide instant re-render of page preview

Version 1.0:

	- Publishing @done
	- Publishing UI
	- Templates @done
	- Hiding
	- Hiding UI
	- Aliasing @done
	- Aliasing UI
	- Users & permissions @done
	- Generators
	- Prototypes @done
	- Test framework (use MiniTest/TestMini)
	- Roles/components/applications ... Need name :(
	- Rendering of published content using pre-generated templates @done
	- Javascript & CSS compression (publishing)
	- Javascript & CSS compression (gem)
	- Schema IDs & migration


Prototypes:

	- Keep it simple: have a #prototype method that is called if it exists on new Content. Within this method you can then add everything you want to the object before it is saved (this should happen after any auto-insertion of slots though) @done
	- Need to figure out an easy way to have multiple prototypes available. Should it be done by having #prototype_with_name and then calling create(:with_name) or having a #prototype(template=nil) and leaving it up to the developer to put in the relevant switches? Am leaning towards the latter. @done

Aliases:

	- syntax like: class SomethingAlias < Spontaneous::Facet; aliases Something; end ? @done
	- alias is a real bit of content, so responds to Page.all etc, but proxies all calls to its aliased item @done
	- need to figure out how to make the proxying work: perhaps a bit of dynamic method deletion on the 'aliases' call @done
	- important that the alias class can also have its own fields (think Culturetheque) @done
	- also important that the list of things we can alias to includes subclasses of the class reference in the 'aliases' call @done
	- NO: it's much simpler than that. Just have a target_id that loads a Content#target and then, if you want to reference the target/aliased objects fields you preface your call with 'target.'. That avoids any proxy/method_missing nonsense. Only problem is with style resolution but that's not too complex. @done
	
	- What about page aliases? Old system worked because there was no actual duplicate page, just an entry. If page aliases are to work then we either need a clever page lookup algorithm (using the target_id on the table) or we need to keep the alias's path & slug  in sync with its target. @done
	
	- Would be nice to have separate page styles for aliases, could perhaps do this by using clever SQL, but might cause problems with template resolution. E.g. Select c3.*, c2.style_id below. Problem with 'target' method is that you can't load the alias and render using the target's styles/templates. Boo. Perhaps define the page style that's used in the class/alias definition. Then the render call has a pre-load where the alias instance is loaded this them sets an instance var on the target to set the style then calls the real render. Hmm. Proxy method much better? @done
	

Publishing:

	- publish creates a 'config.ru' file that requires a specific deployed file, this means that the site is robust against deployment because a particular revision has its codebase hardcoded (which will work with upgrades of gems too as these will require a re-deploy) @done
	- Pathname#realpath will point to a version of the root that doesn't involve symlinks @done
	- revision is hardcoded into ruby rather than a db lookup @done
	- difficulty is with getting the dependencies to load correctly - perhaps a simple pwd change would solve all of this though @done
	- make sure that first_published_at (or whatever) isn't modified if publishing fails @done
	- link success of rendering to success of publishing (i.e. only calling after publish lambdas after render & indexing are complete) @done
	- With sandboxed versions I need some way to restart the public site after a publish is complete. Easy with passenger but what about other frameworks?
	
		See http://unicorn.bogomips.org/SIGNALS.html -- seems like sending a HUP would do exactly what I want.
		The question is: how to let the site know how it sends that signal? Some kind of config option -- a lambda perhaps
		but currently assigning a lambda to a config option just means that lambda is called to return the result. Perhaps this would work?
		Seems nasty.

Config:

	- Current setup doesn't allow any room for non-value based config. i.e. there's no room for initialisation code in any of the config/* files @done
	- Change environment.rb away from a config file, or add another initialisation file where you can run actual code? Wrap config settings in the environment/*.rb files in a call so that rest of file can run code-based init commands? See how rails3 does it... @done
	- Wrap config settings in a call so that the env file can just be required rather than eval'd -- this will allow running of custom code in environment/*.rb (see e.g. problems with restart call after publication) @done
	- Add 'initializers' dir (like rails3)?
	- Update boot.rb to match style of that found in Rails3

Command Line:

	- binary is 'spot' -- yeah! @done
	- 'spot gen site www.example.com' @done
	- 'spot console' @done
	- 'spot browse' @done
	- have a good look at thor or alternatives @done
	- spot init should force root user for db creation and then automatically create user defined in database.yml

Design:

	- Look at Frutiger as an interface font (distribution nightmare - open source equivalents?) @done

Users & Permissions:

	- User editable/db driven groups (?) @done
	- Work out roles of User levels, groups & individual permissions. How to manage the code-db bridge? Levels:code, Groups:db?, Users:db @done
	
		Perhaps page permissions should only address groups. Replace users in current model with groups. Like on unix, creating a user also creates a group of which they are the only member. That would enable ACL style access. If single-user-groups (SUGs) are flagged as such then interface becomes easier as list of real groups is not overwhelmed by these virtual SUGs.
	
	- Do I need solid query language in order to express group access perms? How to express "just this page", "just this page and all it's children" (and more complex variations on this, think CSS selectors) or "all pages" in a way suitable for storing in a db?
	- Assuming I do need a query language what should the syntax be? Again, think CSS:
	
	See http://api.jquery.com/category/selectors/ for ideas
	
	  .class			-> .schema type/ruby class selectors
	  #id					-> page uids
	  234					-> Page IDs
	  /path				-> Page paths
	  @[slotname]	-> a particular slot
	  @[1..3]			-> a range of slots (slots 1, 2 & 3 in this case)
	  @[1,3]			-> slots with indexes 1 & 4
	
	Some examples:-
	
		*																-> everything
	  /about > Person								-> all content of type 'Person' on the page found at path /about
	  #welcome@[1]										-> first slot on page with uid 'welcome'
	  #welcome@[images,people]				-> slots 'images' and 'people' on page with uid 'welcome'
	  #welcome@[Text]								-> all slots of type 'Text' on page #welcome
	  12 > House[title~="Mouse"]			-> all content of type 'House' on page with id 12 whose 'title' field contains 'Mouse'
		#projects Image								-> all content on page with uid 'projects' and its child-pages of type 'Image'
		#projects > *                   -> all content of page #projects
	
	What about selecting by slugs? What about selecting all pages & all non-pages?
	
	 #*			-> every page
	 #* > *  -> every non-page
	
	- Allow programatic refusal to perform certain actions using lambdas. E.g. if you want to disable the deletion of a particular type if it's not empty, then setting the permissions to that type as a lambda { return false unless entries.empty? } would stop accidental deletion
	
	- Actions:
	  * Field
	    * View
	    * Update
	  * Facet
	    * Edit (calculated -- if no fields have write permission then its not editable)
	  * Slots
	    * View - slots get special treatment, they are only editable from within the schema
	    * Add (per type)
	  * Entries
	    * View entry
	    * Add entry
	    * Delete entry
	    * Reorder entries
	    * Hide entry
	  * Pages
	    * View page
	    * Hide page
	    * Change path
	
	- Meta actions:
	  * user_level => [*all]
	  * edit       => [view, edit, add_entry]
	
	
Sequel:

	- Creating associations without saving. Currently associations need the parent to have an id -- this sucks, especially for my ideas for prototypes @done

Update Workflow:

	Need to think about the workflow for updates to css. Have just had situation on BP where I updated the CSS but this meant that incremental publishes broke the live site. How to avoid this? Sandboxing the published version doesn't work because we're talking about changes after publishing.
	
	Ideally you'd tie the CSS to the page, so publishing a page means publishing the CSS and everything remains consistent. I've tried this stuff before in v1 and the result was a disaster.
	
	This comes back to the idea of type-fields -- like class variables but for content. However in the BP case above that wouldn't have worked, what would have been needed was a way to link updates to CSS with publication of an individual page, not a class of pages.
	
	Maybe I should just have done the update to the CSS better. Making the new version backwardly compatible so that incremenatal publishes would work.


PDFs:

	- Find more generic way to re-produce the v1 "PDF" link option. Instead of making this PDF only, I could generalise it into a system where you define a content type, one of its fields and name to give this selection and it will append this list of links onto the set available in text editors.
	  Add tabs to page browser in link popup so that that section becomes a 'link to CMS content' pane

Optimisation/Ideas:

	- Bundle HWIA gem (https://github.com/methodmissing/hwia) and use StrHash / (Hash with indifferent access) liberally
	- Move to Active Support 3
	


Versions:

	- Remove support for 1.8.6

Smells:

	- Slot definitions -- very confusing @done
	- Default template choosing and styles in general. Too many old decisions messing things up.


Rendering Rewrite:

	- Re-write template engine API @done



Boxes:

	- Deletion of boxes leaves stray content around. How to signal the deletion of a box? Would the schema migration system handle this? Options for migrations would be replace/delete...
	
	- Styles
	
	class ABoxClass < Box
	  inline_style :monkey
	  inline_style :crazy
	end
	
	class SomeContent
	  box :images
	  ## templates/some_content/images.html.cut
	  # OR if that template doesn't exist
	  ## <anonymous>
	
	
	  box :images do
	    inline_style :something
	  end
	  ## templates/some_content/something.html.cut
	  # OR if that template doesn't exist
	  ## templates/something.html.cut
	
	
	  # using the same template for multiple boxes
	
	  box :images, :style => :listy
	  box :more_images, :style => :listy
	
	  ## templates/some_content/listy.html.cut
	  # OR if that template doesn't exist
	  ## templates/listy.html.cut
	
	
	  box :images, :class => :ABoxClass
	
	  # chooses the box class's default style which is
	  ## templates/a_box_class/monkey.html.cut
	  # OR
	  ## templates/a_box_class.html.cut
	  # OR if that template doesn't exist
	  ## <anonymous>
	
	
	
	
	  # selecting an existing style on ABoxClass
	  box :images, :class => :ABoxClass, :style => :monkey
	
	  # templates/a_box_class/monkey.html.cut
	
	
	  box :images, :class => :ABoxClass
	    inline_style :naughty
	  end
	
	  ## templates/some_content/naughty.html.cut
	  # OR if that template doesn't exist
	  ## templates/naughty.html.cut
	end

Pages:
	- Keep URL history so that changing path will redirect to the last page to have that URL (unless another page has the same URL)
	- Templates for mobile browsers e.g.
	
	  page_style :iphone, :user_agent => :iphone
	
	Have preconfigured user-agent regexps
	
	But, is this as useful as having template helpers that do the heavy lifting with CSS media queries? Both would be good: user-agent templates and CSS media query helpers AND user-agent template helpers

Blog Posts:

	- A/B testing (using request_show). Can easily provide the code by having an 'examples' project on the spontaneous github acct (must look at easy ways to bootstrap sites from example code, shouldn't be hard)

Search:

	- Have a configurable 'title' column in the db. Individual types can set this up using a 'title_field' call or by over-riding a method

Publishing:

	- Have a check after someone has launched a publish to make sure that no-one has modified the site in between them viewing the publish list and hitting 'publish'. Not sure that this will be 100% reliable. Would have to check modified list of any new changes against modified list of changes included in publish. Would have to add a time to the info in the change list.
	- Add 'before_publish' & 'after_publish' hooks to Site, Page & Piece. 

For Site, you should be able to pass a block:

	Site.after_publish do
	  # do something after publish
	end
	
	this is added to a list of things to run after publish, a la Padrino. Page & Piece can just use the class inheritance/super methodology to do the same thing.
	
Markdown:

	- Ranges fix themselves to strip whitespace and catch missed delimiters @done
	- Highlight active styles using Borders & background colours @done
	- Popup for links has tabs for local pages, URL entry & custom field linking (see above) @done
	- Not sure that Popup for links should be positioned over text - would move input area away from mouse arbitrarily. Perhaps instead of fixed toolbar I show a floating one with the actions? More difficult but would be great
	- Change font to Lucida Grande: helvetica is too fussy & letters too small for easy editing (need windows equivalent though) @done
	- Change selection colour based on selected text?? @done
	- Resizing of textareas - perhaps automatically? Show as standard size initially but then resize to fit text on focus (and shrink on blur). Only grow during editing if amount of text changes significantly, say you can only see 50% of text. Textarea resizes up to some max height rather than just as big as the text. Max height determined by window size: no point having it bigger than window because you're just moving the need to scroll away from the textarea an into the window.  @done
	- Manual vertical resize of text areas
	- Disable built in resizing of textarea in webkit & ff.
	- MOve to Kramdown
	
Workflow:

	- definitions of functions in dsl

Uploads:
	- Check for implementations of Blob.slice to enable creation of large-file uploader using ranges and hashes
	
Blog:
	- RSS is just another format!
	- Have blog section and blog post plugin with RSS templates included
		plugin Spontaneous::Blog
		plugin Spontaneous::BlogPost
	- Blog post plugin defines over-ridable methods to populate standard fields in RSS, e.g.
		def rss_title; end
		def rss_date; end
		def rss_body; end # (method names should match tag names in RSS spec)
	- How to include RSS templates into the 'plugin' and then make sure that they're searched for relative to the plugin file rather than the schema defininition?

Schema:
	- have a schema version id in the db so that on deploy we can do checks
	- have checks delete boxes when appropriate -- hanging box in db => delete it
	- make sure that db is backed up before destructive db changes


Deployment:
	- have some kind of script/system to create a shell system that's set up as a host for multiple cms instances
	- then use simple cap recipies to deploy to this
	- unicorn behind nginx really does look like the best option (for front anyway, back could be simpler)
	- do i still need to enforce a single back process?
	- possible to use, say, redis for publishing to?? 
	- Or this: http://blogs.innodb.com/wp/2011/04/get-started-with-innodb-memcached-daemon-plugin/ -- publish to mysql as normal but then access it using memcache protocol

	
Fields:
	- must tidy up current lookup mess, move to namedset developed for boxes
	- fields must process raw value once for each format supported
	- replace simple "processed_value" column value with a hash containing one value for each format outputted (with a default of :html & :plain)
	- possible to determine which formats are needed by asking the owning content?? (yes I think)
	- move to kramdown so that we can produce intermediate format and then to final
	- have all fields support a 'plain' format (built in 'strip_tags')
	- each field has a 'version' value to help with multi-user situations

Visibility/Hiding:
	- every access to content (ancestors, children... find them all!) must have all_ and visible_ versions much like 'pieces' does so that it's almost impossible for templates to accidentally include invisible content
	- perhaps work the above check into the context -- when loading the content it checks for visibility and if it finds that the item is invisible it simply returns '' for the render call -- probably won't catch all possible uses though (e.g. iterating & outputting properties rather than render calls)
	- 
