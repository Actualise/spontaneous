UI:
- Browser feature detection
- Loading progress @done


- Uploads continue even when moving away from page @done
- Return to page restores individual progress bars @done

- Saving does text then queues images (through same progress mechanism as D&D image replacement) @done
- Save item doesn't block @done
- Estimated time for Uploads @done
- Dual progress bar or have unified one only in status bar and rely in re-linking of individual progress indicators? @done
- Should be able to drop images onto image preview in editing dialogue
- 'Escape' should close/cancel dialogue @done
- 'Format' switch in preview view
- Show URL in preview view
- Back & forward buttons in preview view?
- Save state with # parts @done
- UI reflects all changes to page title
- Page entries have toggle to show & hide fields
- Paging of entries
- URL editing @done
- Cancel by ESC & button for URL editing @done
- Separate treatment of title field in page?

- Only accepting certain formats for d&d (link field formats to UI)

- Attach URL editing/displaying box to bottom of page-info and then animate #page-info {height:'+10'} to expand for editing... @done
- Preview mode is not using the edited URL of current page

- Editing of page UID

Backend:

- Lightweight config system, requirable independently @done
- Config DSL without fixed keys @done
- Fix image insertion on creation using after_save instance hook?
- Look into Text not rendering on Project pages @done
- Look into inline image size definitions not working (see Project in example application) @done
- Files should have their names sanitised @done
- Move ALT text into image attributes?

Templates:
- {{ }}, {$ $}, {% %} ==> #{ }, ${ }, %{ } @done
- Context is clever about what is rendered render(format) called on objects or to_s if #render not found @done
- Cutaneous, "Of the skin" (.cut)? @done
- Instantaneous, "Occurring, arising, or functioning without any delay" (.ins)? @done
- Some useful handling of invalid tags in template
- Look at fix for Spontaneous:: namespace (i.e. can't just use 'Site' have to use Spontaneous:Site)
- Switch to kramdown for markdown processing http://kramdown.rubyforge.org/index.html

Preview:

- Track modification and provide instant re-render of page preview

Version 1.0:

- Publishing
- Templates
- Hiding
- Aliasing
- Users & permissions
-

Aliases:

- syntax like: class SomethingAlias < Spontaneous::Facet; aliases Something; end ? @done
- alias is a real bit of content, so responds to Page.all etc, but proxies all calls to its aliased item @done
- need to figure out how to make the proxying work: perhaps a bit of dynamic method deletion on the 'aliases' call @done
- important that the alias class can also have its own fields (think Culturetheque) @done
- also important that the list of things we can alias to includes subclasses of the class reference in the 'aliases' call @done
- NO: it's much simpler than that. Just have a target_id that loads a Content#target and then, if you want to reference the target/aliased objects fields you preface your call with 'target.'. That avoids any proxy/method_missing nonsense. Only problem is with style resolution but that's not too complex. @done

- What about page aliases? Old system worked because there was no actual duplicate page, just an entry. If page aliases are to work then we either need a clever page lookup algorithm (using the target_id on the table) or we need to keep the alias's path & slug  in sync with its target. @done

- Would be nice to have separate page styles for aliases, could perhaps do this by using clever SQL, but might cause problems with template resolution. E.g. Select c3.*, c2.style_id below. Problem with 'target' method is that you can't load the alias and render using the target's styles/templates. Boo. Perhaps define the page style that's used in the class/alias definition. Then the render call has a pre-load where the alias instance is loaded this them sets an instance var on the target to set the style then calls the real render. Hmm. Proxy method much better?@done


Publishing:

- publish creates a 'config.ru' file that requires a specific deployed file, this means that the site is robust against deployment because a particular revision has its codebase hardcoded (which will work with upgrades of gems too as these will require a re-deploy) @done
- Pathname#realpath will point to a version of the root that doesn't involve symlinks @done
- revision is hardcoded into ruby rather than a db lookup @done
- difficulty is with getting the dependencies to load correctly - perhaps a simple pwd change would solve all of this though @done
- make sure that first_published_at (or whatever) isn't modified if publishing fails @done
- link success of rendering to success of publishing (i.e. only calling after publish lambdas after render & indexing are complete) @done

Command Line:

- binary is 'spot' -- yeah! @done
- 'spot gen site www.example.com' @done
- 'spot console' @done
- have a good look at thor or alternatives @done

Design:

- Look at Frutiger as an interface font (distribution nightmare - open source equivalents?) @done

Users & Permissions:

- User editable/db driven groups (?)
- Work out roles of User levels, groups & individual permissions. How to manage the code-db bridge? Levels:code, Groups:db?, Users:db

Perhaps page permissions should only address groups. Replace users in current model with groups. Like on unix, creating a user also creates a group of which they are the only member. That would enable ACL style access. If single-user-groups (SUGs) are flagged as such then interface becomes easier as list of real groups is not overwhelmed by these virtual SUGs.

- Do I need solid query language in order to express group access perms? How to express "just this page", "just this page and all it's children" (and more complex variations on this, think CSS selectors) or "all pages" in a way suitable for storing in a db?
- Assuming I do need a query language what should the syntax be? Again, think CSS:

See http://api.jquery.com/category/selectors/ for ideas

  .class			-> .schema type/ruby class selectors
  #id					-> page uids
  234					-> Page IDs
  /path				-> Page paths
  @[slotname]	-> a particular slot
  @[1..3]			-> a range of slots (slots 1, 2 & 3 in this case)
  @[1,3]			-> slots with indexes 1 & 4

Some examples:-

	*																-> everything
  /about > .Person								-> all content of type 'Person' on the page found at path /about
  #welcome@[1]										-> first slot on page with uid 'welcome'
  #welcome@[images,people]				-> slots 'images' and 'people' on page with uid 'welcome'
  #welcome@[.Text]								-> all slots of type 'Text' on page #welcome
  12 > .House[title~="Mouse"]			-> all content of type 'House' on page with id 12 whose 'title' field contains 'Mouse'
	#projects .Image								-> all content on page with uid 'projects' and its child-pages of type 'Image'
	#projects > *                   -> all content of page #projects

What about selecting by slugs? What about selecting all pages & all non-pages?

